name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    # Run CI on PRs as well (no release job will execute on PRs)

permissions:
  contents: read          # minimal default; jobs override if needing write
  id-token: write         # OIDC token (future use, provenance, etc.)

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true
  # Ensures only one workflow runs per branch at a time (cancels previous if new push arrives),
  # preventing overlapping releases on multiple rapid pushes.

jobs:
  test:
    name: ðŸŽ¯ Run Pytest Unit Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'
      - name: Install test dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pytest
      - name: Run tests
        run: pytest -q tests/test_scripts.py
        # Executes the test suite (e.g. tests/test_scripts.py) with quiet output

  coding-hours:
    name: ðŸ“Š Generate Coding Hours Report
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code (full history for git-hours)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0   # fetch all commits for accurate git-hours analysis
      - name: Run git-hours (compute coding hours)
        id: ghours
        uses: ./.github/actions/git-hours
        with:
          version: v0.0.6           # **Pinned** version of lazypic/git-hours (was `latest`):contentReference[oaicite:0]{index=0}:contentReference[oaicite:1]{index=1}
        continue-on-error: true     # Allow this step to fail without failing the job (graceful failure)
      - name: Upload coding-hours artifact
        if: ${{ steps.ghours.outcome == 'success' }}
        uses: actions/upload-artifact@v4
        with:
          name: git-hours-${{ github.run_number }}.json
          path: git-hours.json
          if-no-files-found: ignore
        # Upload the git-hours.json report (with a unique name per run). 
        # This will be skipped if git-hours failed or no report was generated.

  release:
    name: ðŸš€ Release (Tag & Publish)
    runs-on: ubuntu-latest
    needs: [test]   # Only run after tests pass
    if: ${{ github.ref == 'refs/heads/main' }}  # Only trigger release job on pushes to main branch
    permissions:
      contents: write   # needed to tag the repo and create release
    env:
      # Pass GitHub token to CLI for auth
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Checkout code (full history for tagging)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine next semantic version
        id: setver
        shell: bash
        run: |
          set -euo pipefail
          # Get the latest tag matching semver (e.g. vX.Y.Z or vX)
          latestTag=$(git tag -l "v*" | sort -V | tail -n1)
          if [[ -z "$latestTag" ]]; then
            echo "No existing tag found, defaulting to v1.0.0"
            newTag="v1.0.0"
          else
            # Parse current version components (handle tags like v6 or v6.0.0)
            [[ "$latestTag" =~ ^v([0-9]+)(?:\.([0-9]+))?(?:\.([0-9]+))?$ ]]
            major=${BASH_REMATCH[1]}
            minor=${BASH_REMATCH[2]:-0}
            patch=${BASH_REMATCH[3]:-0}
            # Determine bump level based on commit messages since last tag
            commit_messages=$(git log "${latestTag}"..HEAD --pretty=format:%B)
            if echo "$commit_messages" | grep -qiE 'BREAKING CHANGE|BREAKING-CHANGE|^.*!:';
            then
              major=$((major+1)); minor=0; patch=0   # major bump for breaking changes:contentReference[oaicite:2]{index=2}
            elif echo "$commit_messages" | grep -qiE '^feat(\(|:)' ;
            then
              minor=$((minor+1)); patch=0           # minor bump for features
            else
              patch=$((patch+1))                    # patch bump for fixes or misc changes
            fi
            newTag="v${major}.${minor}.${patch}"
          fi
          echo "New version to release: $newTag"
          # Output the new tag
          echo "new_version=$newTag" >> $GITHUB_OUTPUT

      - name: Run git-hours for release (generate latest report)
        id: ghours_release
        uses: ./.github/actions/git-hours
        with:
          version: v0.0.6    # use pinned git-hours version (ensures deterministic output)
        continue-on-error: true
        # We run git-hours here as well to attach the latest coding-hours JSON to the release.
        # This step failing will not block the release.

      - name: Create GitHub Release (with auto changelog)
        id: create_release
        shell: bash
        run: |
          set -euo pipefail
          TAG="${{ steps.setver.outputs.new_version }}"
          echo "Releasing $TAG on commit $GITHUB_SHA"
          # Create an annotated tag and push it to the repo
          git config user.name "github-actions"; git config user.email "actions@users.noreply.github.com"
          git tag -a "$TAG" -m "Release $TAG"
          git push origin "$TAG"
          # Use GitHub CLI to create release with auto-generated notes
          if [ -f "git-hours.json" ]; then 
            gh release create "$TAG" --generate-notes "git-hours.json"
          else 
            gh release create "$TAG" --generate-notes 
          fi
        # This step tags the repository with the new version and creates a GitHub Release.
        # The `--generate-notes` flag tells GitHub to auto-generate the release title/body from commits and PRs:contentReference[oaicite:3]{index=3}.
        # If a git-hours report was produced, it is attached as a release asset; otherwise, the release is created without it.
